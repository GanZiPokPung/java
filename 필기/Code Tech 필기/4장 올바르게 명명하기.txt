컴퓨터 과학에서 어려운 문제는 딱 두 가지, 캐시 무효화(cache invalidation)와 명명(naming)이다. -필 칼튼

좋은 이름을 짓는 것은 무척 어렵다. 전문가도 처음부터 좋은 이름을 구상하기는 어렵다. 

코드 요소를 명명하는 것은 훨씬 더 어렵다. 코드에서는 쉽게 알아챌 수 있는 다른 특징이 없기 때문이다. 추상적일 뿐만 아니라 대체로 전혀 새롭고 특정 도메인에만 귀속된다. 

그래서 프로그래밍에서는 훌륭한 명명이 매우 중요하다. 패키지, 클래스, 메서드, 지역 변수, 매개변수 등 명명할 요소가 너무나도 많다. 일반적으로 이러한 요소는 불분명하거나 이해하기 힘든 개념을 표현하다 보니 처음부터 좋은 이름을 짓는 것은 정말로 어렵다. 

이 장에서는 비교를 통해 코드 요소에 더 걸맞는 이름을 할당하는 방법을 배운다. 

1. 자바 명명 규칙 사용하기
자바는 패키지, 클래스, 인터페이스, 열거형, 메서드, 변수, 매개변수, 상수 등 수많은 요소를 명명해야 한다. 

위 코드의 이상한 점은 무엇일까? 모두 일관되도록 CamelCase로 명명해 공백없이 모든 단어가 대문자로 시작된다. 그러면 일관성이 있는 경우에는 아무 방식이나 써도 되는걸까?

이론적으로는 맞지만 실제로는 아니다! 위 코드는 기능상의 오류는 없지만 자바 프로그래머에게 자바 코드처럼 읽히지 않는다.

그러면 자바처럼 보이게 하려면 코드를 어떻게 바꾸어야 할까?

자바처럼 보이게 하려면 자바 규칙에 맞춰 명명해야 한다. 자바 코드 규칙은 자바 코드를 서식화하는 실질적 표준이다. 

class 명은 이미 대문자로 시작하고 CamelCase로 작성되었으므로 넘어간다. 

상수는 두드러지가 표현하기 위해 CAPITAL_SNAKE_CASE로 작성해야 한다. 이름 내 모든 철자가 대문자이며 용어를 밑줄로 구분한다. 마치 상수가 절대 바뀌지 않겠다고 몸짓하는것 처럼..

메서드 명은 get, set, save, is, has 처럼 동사로 시작해야 한다. 그리고 변수 명은 명사를 사용한다. 

자바 코드 규칙은 훌륭한 명명의 첫 단추일 뿐이다. 요점은 규칙을 따르지 않으면 절대로 좋은 이름을 얻을 수 없다는 것이다. 규칙은 기본 조건이다.

2. 프레임워크에는 Getter/Setter 사용하기
OOP 언어에서는 외부에서 클래스 필드에 직접 접근하는 경우가 드물다. 대신 접근을 제어할 게터와 세터 메서드를 작성한다.

게터와 세터의 구조와 명명은 표준화가 잘 되어 있어 여러 프레임워크에서 대부분 따르고 있다. 

위 코드를 살펴보자. 각 필드마다 올바르게 명명된 게터와 세터가 있는가? 매개변수가 없는 생성자도 있는가? 가시성 수준은 적절한가?

그렇지 않다. 프레임워크에서 위 클래스의 인스턴스를 사용하면 이상한 사건들이 발생한다. 예외를 던지는 프레임워크는 거의 없지만 조용히 실패하거나 원치 않는 방식으로 동작한다.

그렇다면 어떻게 바꾸어야 위 클래스를 자바 빈(게터,세터만의 명세)으로 변경할 수 있을까?

이제 유효한 자바 빈 클래스가 되었다. 먼저 필드 한정자를 private으로, 게터와 세터는 public으로 바꿨다.
이로써 프레임워크는 게터와 세터를 사용해야 하며 게터와 세터 없이 필드에 직접 접근할 수 없게 되었다.

다음으로 기본 생성자를 추가하였다. 기본 생성자는 대부분의 프레임워크에서 필요한데 기본 생성자로 클래스의 빈 인스턴스를 만든 후 설정할 때는 세터를 호출해 필드에 값을 할당한다. 매개변수를 가지는 생성자를 추가하면 기본 생성자를 더 이상 쓸 수 없다는 특징이 있기 때문이다. 

마지막으로 필드명을 넣어 게터와 세터를 다시 명명했다. 필드명이 foo라면 getFoo(), setFoo() 처럼 명명한다. 다만 boolean 필드는 좀 다르다. 세터명은 그대로지만 게터는 질문하듯이 isFoo()라고 명명한다. 안타깝게 자바에서는 메서드명에 물음표를 넣을 수 없다.

3. 한 글자로 명명하지 않기
어떤 코드 기반이든 이름이 한 글자인 변수가 있기 마련이다. 이는 꽤 흔한 일이다. 하지만 이 덕분에 코드는 훨씬 읽기 어려워진다. 단지 글자 하나로 의미를 얼마나 전달할 수 있겠는가?

위코드를 보자. 메서드 내 변수가 모두 n, l, h, m, c, s 처럼 이름이 한 글자이다. 흔한 이진 검색 코드이지만 한 글자 변수 덕분에 코드를 읽는데에 큰 어려움을 준다. 

한글자 이름에는 이유라는게 있을 수 없다. 이론가는 편하다고 그냥 쓰고 싶다고 하지만 코드는 단순한 수학 이론같은게 아니다. 일반적으로 프로그래머는 하루에도 코드를 수천줄 읽는다. 변수명이 계속 반복되고 코드 맥락에 어긋나면 읽기가 점점 어려워 진다. 그래서 변수명에 이름을 붙여야 하는데, 이름은 한글자로 충족이 불가능하다.

이제 변수명이 길어지면 어떻게 달라지는지 보자.

놀랍지 않은가? 전체 이름이 없었다면 한 글자 짜리 변수명들의 의미를 모두 외웠어야 했다. 

하지만 코드에 전체 이름을 넣으면 외울 필요가 전혀 없다. 이름이 길어 코드가 비효율적으로 될까 걱정할 수도 있지만 그렇지 않다. 컴파일 과정을 거쳐 나오는 바이트코드는 변수명이 한글자가 아니라고 해서 불편을 주거나 그런것은 전혀 없다.  어차피 바이트 코드는 기계가 읽는다. 

4. 축약 쓰지 않기
세상에는 무수한 축약어가 존재한다. 코드에 자신만의 축약어를 만들려는 프로그래머는 생각보다 많다. 그 축약을 아는 사람은 오로지 자신 뿐이다. 다른 사람은 축약어를 거의 모두 새로 배워야 한다. 이는 곧 시간소모로 이어진다. 그러니 코드를 더 빨리 이해하고 짜증도 덜 나려면 축약은 절대 쓰지 않는 것이 낫다.

위 코드는 축약어가 너무 많다. 맥락을 알지 못하면 bufW나 dirStr의 뜻을 알기 어렵다. 변수 타입인 BufferedWriter와 DirectoryStream을 함께 보면 더 명확해지지만 쓸데없이 어렵긴 마찬가지이다.

그러면 축약을 어떻게 바꾸어야 할까?

규칙은 지극히 간단하다. 흔히 쓰이는 축약만 사용하고 그 외에는 전체 이름을 사용하자.
위 코드를 보자. 이해하기 훨씬 쉽고 이상한 변수명도 보이지 않는다.

가능하면 축약은 피하고 매우 일반적인 경우에만 사용하자. 확인이 없으면 풀어쓰자. 