RPG 게임에서 자신이 플레이하는 캐릭터는 경험치를 모아 레벨 업을 하면 스킬 숙련도가 올라가며 점점 더 강해진다. 

프로그래밍도 이와 다를바 없다. 프로그래밍에서는 캐릭터가 바로 나 자신이다. 프로그래머는 여러가지 경험을 통해 프로그래밍 숙련 레벨을 올릴수 있다. 이러한 스킬을 쌓으려면 어떻게 해야 할까?

이 장에서는 1장에서 봤던 기초적인 내용을 뛰어 넘는 레벨업이다. 더향상된 자바 언어 개념과 코드 스타일 측면을 함께 살펴본다.

1. 매직 넘버를 상수로 대체
프로그래머는 코드에서 옵션 집합을 표현할때 종종 숫자 집합을 사용한다. 이러한 숫자를 매직넘버라고 한다. 매직넘버는 표면상의 의미가 없는 숫자이지만 프로그램 동작을 제어한다.

매직넘버가 있으면 코드를 이해하기 어려워지고 오류 발생도 쉽다.

(코드 설명)

이러한 매직넘버가 있으면 이 값을 외워야 하는 번거로움이 있으며 이로 인한 실수도 무시할 수 없다.

컴파일러는 이런 오류를 막을 수 없다. 왜냐하면 문법적으로는 틀린 부분이 없기 때문이다.

어떻게 이 매직넘버를 없애는지 코드를 통해 살펴보자.

static final => 상수(constant) 변경 불가

2. 정수 상수 대신 열거형
위 코드에서 setPreset의 매개변수인 speedPreset은 아직 정수이다. 어떤 숫자든 넣을 수 있으며, 심지어 음수값을 넣을 수도 있다. 

이러한 경우 그저 if의 조건에 맞지 않아 아무 일도 일어나지 않는다. 충돌 보다는 낫지만 그래도 어떤 버그 유형이든 야기할 가능성이 농후하다.

그러면 위 코드를 어떻게 바꿔야 할까?

(코드)
자바 타입 시스템(requireNonNull)은 가끔 들어오는 유효하지 않은 입력값을 막는데 큰 역할 을 한다.
예제 처럼 가능한 옵션을 모두 열거할 수 있다면 항상 enum타입을 사용하자.

더이상 존재하지 않는 SpeedPreset을 setPreset의 메서드로 넣을 수 없다. 시도하여도 컴파일러에서 중지시킨다. 

3. For 루프 대신 For-Each
자료 구조 순회 방법은 정말 많다. 초보자가 흔히 배우는 방법이 반드시 가장 좋은 방법은 아니다.

위 코드는 C스타일 프로그래밍 언어에서 사용하는 전통적인 순회 방법이다. 주로 배열에 쓰이지만 자바는 인덱싱될 컬렉션이라면 어떤 종류가 와도 적용된다. 

하지만 위를 보면 리스트 내 다음 원소가 접근하는 경우가 아니라면 인덱스를 쓰지 않는다. 그렇기 때문에 인덱스를 계속 추적할 필요가 없다.

인덱스 변수가 제공하는 정보를 자세히 알아야 하는 경우는 드물다. 이럴 때에는 세부 순회 내용을 숨기는 식으로 작성하는 것이 좋다.

다행히 자바는 이를 위한 몇 가지 문법을 제공한다.

(코드 설명)

이 코드를 이용하면 기존 For 루프에서 생길 수 있는 IndexOutOfBoundException(인덱스 범위를 벗어나 엉뚱한 메모리를 참조하는 예외)을 예방할 수 있다. 

그렇다면 인덱스를 순회하는 전통적인 방식은 어떤 경우에 사용해야 할까? 정답은 "거의 없다"이다. 대부분 자료 구조 내 각 원소만 처리하고 싶기 때문이다.

인덱스 순회가 적절한 경우는 특정 부분만 순회하거나 명시적으로 다른 목적을 위해 인덱스가 필요할때 뿐이다.

4. 순회하면서 컬렉션 수정하지 않기
보통 배열이나 리스트를 비롯한 다양한 자료 구조를 순회하게 된다. 대부분 찾는 작업을 위한 읽기만을 수행할 것이다. 하지만 이 자료 구조를 바꾸는 경우에는 주의해야 한다. 프로그램의 충돌 위험이 있기 때문이다.

(코드 설명)

supply 중 하나라도 오염된 경우 무조건 충돌한다. 이것보다 더 큰 문제는 문제가 처음 발생하기 전까지는 코드가 잘 동작한다는 것이다.

문제는 supplies.remove(supply)를 호출하는 부분이다. 이 경우 List와 같은 Collection 인터페이스는 ConcurrentModificationException(Collection을 순회하는 동안 수정하여 생기는 예외)을 던진다. 즉 List를 순회하면서 List를 수정할 수 없다. 이 문제는 컴파일러 시점에서 잡아주지 않는다.

그러면 어떻게 해야 올바르게 수행할까?

문제를 해결할 직관적인 방법은 리스트를 순회하며 변질된 제품을 찾고 그 후 앞에서 발견했던 제품을 모두 제거하는 것이다. 먼저 순회하고 나중에 수정하는 접근법이다.

여기서 핵심은 Iterator이다. Iterator는 첫 번째 원소부터 시작해 리스트 내 원소를 가리키는 포인터처럼 동작한다. hasNext()를 통해 원소가 남았는지 검사하고 next()로 다음 원소를 얻어 반환된 마지막 원소를 remove()로 안전하게 제거한다.