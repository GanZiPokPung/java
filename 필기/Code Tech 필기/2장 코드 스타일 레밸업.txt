RPG 게임에서 자신이 플레이하는 캐릭터는 경험치를 모아 레벨 업을 하면 스킬 숙련도가 올라가며 점점 더 강해진다. 

프로그래밍도 이와 다를바 없다. 프로그래밍에서는 캐릭터가 바로 나 자신이다. 프로그래머는 여러가지 경험을 통해 프로그래밍 숙련 레벨을 올릴수 있다. 이러한 스킬을 쌓으려면 어떻게 해야 할까?

이 장에서는 1장에서 봤던 기초적인 내용을 뛰어 넘는 레벨업이다. 더향상된 자바 언어 개념과 코드 스타일 측면을 함께 살펴본다.

1. 매직 넘버를 상수로 대체
프로그래머는 코드에서 옵션 집합을 표현할때 종종 숫자 집합을 사용한다. 이러한 숫자를 매직넘버라고 한다. 매직넘버는 표면상의 의미가 없는 숫자이지만 프로그램 동작을 제어한다.

매직넘버가 있으면 코드를 이해하기 어려워지고 오류 발생도 쉽다.

(코드 설명)

이러한 매직넘버가 있으면 이 값을 외워야 하는 번거로움이 있으며 이로 인한 실수도 무시할 수 없다.

컴파일러는 이런 오류를 막을 수 없다. 왜냐하면 문법적으로는 틀린 부분이 없기 때문이다.

어떻게 이 매직넘버를 없애는지 코드를 통해 살펴보자.

static final => 상수(constant) 변경 불가

2. 정수 상수 대신 열거형
위 코드에서 setPreset의 매개변수인 speedPreset은 아직 정수이다. 어떤 숫자든 넣을 수 있으며, 심지어 음수값을 넣을 수도 있다. 

이러한 경우 그저 if의 조건에 맞지 않아 아무 일도 일어나지 않는다. 충돌 보다는 낫지만 그래도 어떤 버그 유형이든 야기할 가능성이 농후하다.

그러면 위 코드를 어떻게 바꿔야 할까?

(코드)
자바 타입 시스템(requireNonNull)은 가끔 들어오는 유효하지 않은 입력값을 막는데 큰 역할 을 한다.
예제 처럼 가능한 옵션을 모두 열거할 수 있다면 항상 enum타입을 사용하자.

더이상 존재하지 않는 SpeedPreset을 setPreset의 메서드로 넣을 수 없다. 시도하여도 컴파일러에서 중지시킨다. 

3. For 루프 대신 For-Each
자료 구조 순회 방법은 정말 많다. 초보자가 흔히 배우는 방법이 반드시 가장 좋은 방법은 아니다.

위 코드는 C스타일 프로그래밍 언어에서 사용하는 전통적인 순회 방법이다. 주로 배열에 쓰이지만 자바는 인덱싱될 컬렉션이라면 어떤 종류가 와도 적용된다. 

하지만 위를 보면 리스트 내 다음 원소가 접근하는 경우가 아니라면 인덱스를 쓰지 않는다. 그렇기 때문에 인덱스를 계속 추적할 필요가 없다.

인덱스 변수가 제공하는 정보를 자세히 알아야 하는 경우는 드물다. 이럴 때에는 세부 순회 내용을 숨기는 식으로 작성하는 것이 좋다.

다행히 자바는 이를 위한 몇 가지 문법을 제공한다.

(코드 설명)

이 코드를 이용하면 기존 For 루프에서 생길 수 있는 IndexOutOfBoundException(인덱스 범위를 벗어나 엉뚱한 메모리를 참조하는 예외)을 예방할 수 있다. 

그렇다면 인덱스를 순회하는 전통적인 방식은 어떤 경우에 사용해야 할까? 정답은 "거의 없다"이다. 대부분 자료 구조 내 각 원소만 처리하고 싶기 때문이다.

인덱스 순회가 적절한 경우는 특정 부분만 순회하거나 명시적으로 다른 목적을 위해 인덱스가 필요할때 뿐이다.

4. 순회하면서 컬렉션 수정하지 않기
보통 배열이나 리스트를 비롯한 다양한 자료 구조를 순회하게 된다. 대부분 찾는 작업을 위한 읽기만을 수행할 것이다. 하지만 이 자료 구조를 바꾸는 경우에는 주의해야 한다. 프로그램의 충돌 위험이 있기 때문이다.

(코드 설명)

supply 중 하나라도 오염된 경우 무조건 충돌한다. 이것보다 더 큰 문제는 문제가 처음 발생하기 전까지는 코드가 잘 동작한다는 것이다.

문제는 supplies.remove(supply)를 호출하는 부분이다. 이 경우 List와 같은 Collection 인터페이스는 ConcurrentModificationException(Collection을 순회하는 동안 수정하여 생기는 예외)을 던진다. 즉 List를 순회하면서 List를 수정할 수 없다. 이 문제는 컴파일러 시점에서 잡아주지 않는다.

그러면 어떻게 해야 올바르게 수행할까?

문제를 해결할 직관적인 방법은 리스트를 순회하며 변질된 제품을 찾고 그 후 앞에서 발견했던 제품을 모두 제거하는 것이다. 먼저 순회하고 나중에 수정하는 접근법이다.

여기서 핵심은 Iterator이다. Iterator는 첫 번째 원소부터 시작해 리스트 내 원소를 가리키는 포인터처럼 동작한다. hasNext()를 통해 원소가 남았는지 검사하고 next()로 다음 원소를 얻어 반환된 마지막 원소를 remove()로 안전하게 제거한다.

5. 순회하며 계산 집약적 연산하지 않기
자료 구조를 순회 할때는 수행할 연산 유형에 유의해야 한다. 성능 위험이 쉽게 초래될 수 있다. 위 코드 => Supply 객체를 찾는 find() 메서드의 전형적인 예

정적 메서드인 matches()를 호출하면서 정규식인 String과 검색할 String을 제공하는 방식은 유용하지만 성능을 저하시키는 요인이 된다.

코드를 실행하면서 자바는 String 표현식인 regex를 가져와 특수한 목적의 오토마톤(automaton, 수학적 모델)을 만든다. 
이 오토마톤을 컴파일하여 supply.toString()과 부합시켜 본다. 정규식 오토마톤 컴파일은 클래스 컴파일처럼 시간과 처리 전력을 소모한다. 일회성 동작에서는 괜찮겠지만 위 코드는 반복할 때마다 정규식을 컴파일 하고 있다.

그렇다면 정규식을 반복하여 컴파일하지 않으려면 어떻게 해야할까?

계산이 많이 필요한 연산은 가능하면 적게 하도록 만들어 주자.
이 경우 정규식을 한번만 컴파일 하기 때문에 반복하여도 표현식 문자열은 바뀌지 않는다.

이렇게 정규식을 조금만 고쳐 사용해도 성능을 크게 높일 수 있다.

6. 새 줄로 그루핑
코드 블럭이 서로 붙어 있으면 보통 한덩어리로 간주한다. 별개  블록을 새줄로 분리하면 코드 이해도를 향상시킬 수 있다.

서로 다른 부분으로 구성된 코드라면 사이에 새줄을 추가해주자. 그러면 훨씬 코드 가독성을 높여준다. 

그러면 빈 줄을 어디에 두어야 할까? 어떤 부분들을 서로 분리해야 하거나 합쳐야 할까?

몇몇 코드 블럭을 새 줄로 분리했다.

(코드 설명)

7. 이어붙이기 대신 서식화
이해도와 가독성은 코드뿐만 아니라 코드가 생성할 출력에서도 중요하다.

긴 문자열을 생성할 때 서식 문자열을 사용하면 더 읽기 쉽게 만들 수 있다. 

위 코드의 문제점은 실제로 출력이 어떤 모습일지 알기 어렵다는 점이다. 

깊은 중첩도, 조건 분기도 없으며, 변수명과 메서드명도 각각의 의미를 지니지만 읽기 어렵다. 

이런 코드는 대폭으로 간소화 시킬 수 있다. 다음 코드를 보자.

서식 문자열로 문제를 해결하는데 자바뿐만 아니라 대부분의 현대 프로그래밍 언어에서 사용할 수 있다. 핵심은 String 레이아웃(어떻게 출력할지)과 데이터(무엇을 출력할지)를 분리하는 것이다.

8. 직접 만들지 말고 자바 API 사용하기
프로그래밍 초창기에는 뭐든 스스로 만들어야 했다. 모든 자료 구조와 알고리즘 유형을 직접 만들어야 했었다. 이는 큰 도움이 되겠지만 시간이 많이 걸리고 오류가 발생하기 쉽다.

시대가 지나며 자바 API는 거대해졌다. 자료구조와 알고리즘 기능을 도와줄 클래스들이 많이 생겨났다. API에 있는 기능은 다시 구현하지 말고 가능하면 재사용해야 한다. 전문가들이 끊임없이 자바 API를 작성하고 최적화 하면서 빠르고 버그도 거의 없는 표준 라이브러리가 만들어지고 있다.

위 코드를 자바 API를 사용하여 고쳐보자.

훨씬 코드가 짧아졌다. 그리고 짧아진만큼 이해하기도 쉬워졌다.

API를 알면 코드의 문제를 훨씬 더 간단히 해결할 수 있다. API는 전세계적으로 광범위한 테스트를 거치기 때문에 버그를 일으킬 가능성이 매우 적다.

API에 정통하면 진정한 자바 전문가로 거듭날 수 있다. 기존 기능을 다시 구현하지 않음으로써 시간이 절약된다.

자바 API를 살펴보자!